-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the types generated from the schema Performance
module IBKR.Types.Performance where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified IBKR.Common
import IBKR.TypeAlias

-- | Defines the object schema located at @components.schemas.performance@ in the specification.
-- 
-- 
data Performance = Performance {
  -- | cps: Cumulative performance data
  performanceCps :: (GHC.Maybe.Maybe PerformanceCps)
  -- | currencyType
  , performanceCurrencyType :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id
  , performanceId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | included
  , performanceIncluded :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | nav: Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks.
  , performanceNav :: (GHC.Maybe.Maybe PerformanceNav)
  -- | pm
  , performancePm :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | rc
  , performanceRc :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | tpps: Time period performance data
  , performanceTpps :: (GHC.Maybe.Maybe PerformanceTpps)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON Performance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cps" Data.Aeson.Types.ToJSON..=)) (performanceCps obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currencyType" Data.Aeson.Types.ToJSON..=)) (performanceCurrencyType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("included" Data.Aeson.Types.ToJSON..=)) (performanceIncluded obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nav" Data.Aeson.Types.ToJSON..=)) (performanceNav obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pm" Data.Aeson.Types.ToJSON..=)) (performancePm obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("rc" Data.Aeson.Types.ToJSON..=)) (performanceRc obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tpps" Data.Aeson.Types.ToJSON..=)) (performanceTpps obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("cps" Data.Aeson.Types.ToJSON..=)) (performanceCps obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currencyType" Data.Aeson.Types.ToJSON..=)) (performanceCurrencyType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("included" Data.Aeson.Types.ToJSON..=)) (performanceIncluded obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("nav" Data.Aeson.Types.ToJSON..=)) (performanceNav obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pm" Data.Aeson.Types.ToJSON..=)) (performancePm obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("rc" Data.Aeson.Types.ToJSON..=)) (performanceRc obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tpps" Data.Aeson.Types.ToJSON..=)) (performanceTpps obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON Performance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Performance" (\obj -> (((((((GHC.Base.pure Performance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "cps")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "currencyType")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "included")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "nav")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pm")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "rc")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tpps"))
-- | Create a new 'Performance' with all required fields.
mkPerformance :: Performance
mkPerformance = Performance{performanceCps = GHC.Maybe.Nothing,
                            performanceCurrencyType = GHC.Maybe.Nothing,
                            performanceId = GHC.Maybe.Nothing,
                            performanceIncluded = GHC.Maybe.Nothing,
                            performanceNav = GHC.Maybe.Nothing,
                            performancePm = GHC.Maybe.Nothing,
                            performanceRc = GHC.Maybe.Nothing,
                            performanceTpps = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.cps@ in the specification.
-- 
-- Cumulative performance data
data PerformanceCps = PerformanceCps {
  -- | data
  performanceCpsData :: (GHC.Maybe.Maybe ([PerformanceCpsData]))
  -- | dates: array of dates, the length should be same as the length of returns inside data.
  , performanceCpsDates :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | freq: D means Day
  , performanceCpsFreq :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceCps
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceCpsData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceCpsDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceCpsFreq obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceCpsData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceCpsDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceCpsFreq obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceCps
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceCps" (\obj -> ((GHC.Base.pure PerformanceCps GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "dates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "freq"))
-- | Create a new 'PerformanceCps' with all required fields.
mkPerformanceCps :: PerformanceCps
mkPerformanceCps = PerformanceCps{performanceCpsData = GHC.Maybe.Nothing,
                                  performanceCpsDates = GHC.Maybe.Nothing,
                                  performanceCpsFreq = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.cps.properties.data.items@ in the specification.
-- 
-- 
data PerformanceCpsData = PerformanceCpsData {
  -- | baseCurrency
  performanceCpsDataBaseCurrency :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | end: end date-- yyyyMMdd
  , performanceCpsDataEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id
  , performanceCpsDataId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | idType: for example-- acctid
  , performanceCpsDataIdType :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | returns: each value stands for price change percent of corresponding date in dates array
  , performanceCpsDataReturns :: (GHC.Maybe.Maybe ([GHC.Types.Double]))
  -- | start: start date-- yyyyMMdd
  , performanceCpsDataStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceCpsData
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceCpsDataStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceCpsData
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceCpsData" (\obj -> (((((GHC.Base.pure PerformanceCpsData GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "baseCurrency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "idType")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "returns")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "start"))
-- | Create a new 'PerformanceCpsData' with all required fields.
mkPerformanceCpsData :: PerformanceCpsData
mkPerformanceCpsData = PerformanceCpsData{performanceCpsDataBaseCurrency = GHC.Maybe.Nothing,
                                          performanceCpsDataEnd = GHC.Maybe.Nothing,
                                          performanceCpsDataId = GHC.Maybe.Nothing,
                                          performanceCpsDataIdType = GHC.Maybe.Nothing,
                                          performanceCpsDataReturns = GHC.Maybe.Nothing,
                                          performanceCpsDataStart = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.nav@ in the specification.
-- 
-- Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks.
data PerformanceNav = PerformanceNav {
  -- | data
  performanceNavData :: (GHC.Maybe.Maybe ([PerformanceNavData]))
  -- | dates: array of dates, the length should be same as the length of returns inside data.
  , performanceNavDates :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | freq: D means Day
  , performanceNavFreq :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceNav
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceNavData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceNavDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceNavFreq obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceNavData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceNavDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceNavFreq obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceNav
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceNav" (\obj -> ((GHC.Base.pure PerformanceNav GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "dates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "freq"))
-- | Create a new 'PerformanceNav' with all required fields.
mkPerformanceNav :: PerformanceNav
mkPerformanceNav = PerformanceNav{performanceNavData = GHC.Maybe.Nothing,
                                  performanceNavDates = GHC.Maybe.Nothing,
                                  performanceNavFreq = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.nav.properties.data.items@ in the specification.
-- 
-- 
data PerformanceNavData = PerformanceNavData {
  -- | baseCurrency
  performanceNavDataBaseCurrency :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | end: end date-- yyyyMMdd
  , performanceNavDataEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id
  , performanceNavDataId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | idType: for example-- acctid
  , performanceNavDataIdType :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | returns: each value stands for price change percent of corresponding date in dates array
  , performanceNavDataReturns :: (GHC.Maybe.Maybe ([GHC.Types.Double]))
  -- | start: start date-- yyyyMMdd
  , performanceNavDataStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceNavData
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceNavDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceNavDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceNavDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceNavDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceNavDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceNavDataStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceNavDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceNavDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceNavDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceNavDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceNavDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceNavDataStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceNavData
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceNavData" (\obj -> (((((GHC.Base.pure PerformanceNavData GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "baseCurrency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "idType")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "returns")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "start"))
-- | Create a new 'PerformanceNavData' with all required fields.
mkPerformanceNavData :: PerformanceNavData
mkPerformanceNavData = PerformanceNavData{performanceNavDataBaseCurrency = GHC.Maybe.Nothing,
                                          performanceNavDataEnd = GHC.Maybe.Nothing,
                                          performanceNavDataId = GHC.Maybe.Nothing,
                                          performanceNavDataIdType = GHC.Maybe.Nothing,
                                          performanceNavDataReturns = GHC.Maybe.Nothing,
                                          performanceNavDataStart = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.tpps@ in the specification.
-- 
-- Time period performance data
data PerformanceTpps = PerformanceTpps {
  -- | data
  performanceTppsData :: (GHC.Maybe.Maybe ([PerformanceTppsData]))
  -- | dates: array of dates, the length should be same as the length of returns inside data.
  , performanceTppsDates :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | freq: M means Month
  , performanceTppsFreq :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceTpps
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceTppsData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceTppsDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceTppsFreq obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("data" Data.Aeson.Types.ToJSON..=)) (performanceTppsData obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("dates" Data.Aeson.Types.ToJSON..=)) (performanceTppsDates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("freq" Data.Aeson.Types.ToJSON..=)) (performanceTppsFreq obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceTpps
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceTpps" (\obj -> ((GHC.Base.pure PerformanceTpps GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "dates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "freq"))
-- | Create a new 'PerformanceTpps' with all required fields.
mkPerformanceTpps :: PerformanceTpps
mkPerformanceTpps = PerformanceTpps{performanceTppsData = GHC.Maybe.Nothing,
                                    performanceTppsDates = GHC.Maybe.Nothing,
                                    performanceTppsFreq = GHC.Maybe.Nothing}
-- | Defines the object schema located at @components.schemas.performance.properties.tpps.properties.data.items@ in the specification.
-- 
-- 
data PerformanceTppsData = PerformanceTppsData {
  -- | baseCurrency
  performanceTppsDataBaseCurrency :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | end: end date-- yyyyMMdd
  , performanceTppsDataEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id
  , performanceTppsDataId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | idType: for example-- acctid
  , performanceTppsDataIdType :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | returns: each value stands for price change percent of corresponding date in dates array
  , performanceTppsDataReturns :: (GHC.Maybe.Maybe ([GHC.Types.Double]))
  -- | start: start date-- yyyyMMdd
  , performanceTppsDataStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PerformanceTppsData
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("baseCurrency" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataBaseCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("end" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("idType" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataIdType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("returns" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataReturns obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("start" Data.Aeson.Types.ToJSON..=)) (performanceTppsDataStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PerformanceTppsData
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PerformanceTppsData" (\obj -> (((((GHC.Base.pure PerformanceTppsData GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "baseCurrency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "end")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "idType")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "returns")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "start"))
-- | Create a new 'PerformanceTppsData' with all required fields.
mkPerformanceTppsData :: PerformanceTppsData
mkPerformanceTppsData = PerformanceTppsData{performanceTppsDataBaseCurrency = GHC.Maybe.Nothing,
                                            performanceTppsDataEnd = GHC.Maybe.Nothing,
                                            performanceTppsDataId = GHC.Maybe.Nothing,
                                            performanceTppsDataIdType = GHC.Maybe.Nothing,
                                            performanceTppsDataReturns = GHC.Maybe.Nothing,
                                            performanceTppsDataStart = GHC.Maybe.Nothing}
