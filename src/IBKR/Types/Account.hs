-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the types generated from the schema Account
module IBKR.Types.Account where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified IBKR.Common
import IBKR.TypeAlias

-- | Defines the object schema located at @components.schemas.account@ in the specification.
-- 
-- account information
data Account = Account {
  -- | accountAlias: User customizable account alias. Refer to [Configure Account Alias](https:\/\/guides.interactivebrokers.com\/cp\/cp.htm\#am\/settings\/accountalias.htm) for details.
  accountAccountAlias :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | accountId: The account number
  , accountAccountId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | accountStatus: When the account was opened in unix time.
  , accountAccountStatus :: (GHC.Maybe.Maybe GHC.Types.Double)
  -- | accountTitle: Title of the account
  , accountAccountTitle :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | accountVan: The accountAlias
  , accountAccountVan :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | clearingStatus: Status of the Account
  --   * O = Open
  --   * P or N = Pending
  --   * A = Abandoned
  --   * R = Rejected
  --   * C = Closed
  , accountClearingStatus :: (GHC.Maybe.Maybe AccountClearingStatus)
  -- | covestor: Is a Covestor Account
  , accountCovestor :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | currency: Base currency of the account.
  , accountCurrency :: (GHC.Maybe.Maybe AccountCurrency)
  -- | desc: Formatted \"accountId - accountAlias\"
  , accountDesc :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | displayName: Whichever value is not null in this priority
  , accountDisplayName :: (GHC.Maybe.Maybe AccountDisplayName)
  -- | faclient: If an account is a sub-account to a Financial Advisor.
  , accountFaclient :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | id: The account identification value
  , accountId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | parent
  , accountParent :: (GHC.Maybe.Maybe AccountParent)
  -- | tradingType: UNI - Deprecated property
  , accountTradingType :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | type: Account Type
  , accountType :: (GHC.Maybe.Maybe AccountType)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON Account
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountAlias" Data.Aeson.Types.ToJSON..=)) (accountAccountAlias obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountId" Data.Aeson.Types.ToJSON..=)) (accountAccountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountStatus" Data.Aeson.Types.ToJSON..=)) (accountAccountStatus obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountTitle" Data.Aeson.Types.ToJSON..=)) (accountAccountTitle obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountVan" Data.Aeson.Types.ToJSON..=)) (accountAccountVan obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("clearingStatus" Data.Aeson.Types.ToJSON..=)) (accountClearingStatus obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("covestor" Data.Aeson.Types.ToJSON..=)) (accountCovestor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency" Data.Aeson.Types.ToJSON..=)) (accountCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("desc" Data.Aeson.Types.ToJSON..=)) (accountDesc obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("displayName" Data.Aeson.Types.ToJSON..=)) (accountDisplayName obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("faclient" Data.Aeson.Types.ToJSON..=)) (accountFaclient obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (accountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("parent" Data.Aeson.Types.ToJSON..=)) (accountParent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tradingType" Data.Aeson.Types.ToJSON..=)) (accountTradingType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (accountType obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountAlias" Data.Aeson.Types.ToJSON..=)) (accountAccountAlias obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountId" Data.Aeson.Types.ToJSON..=)) (accountAccountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountStatus" Data.Aeson.Types.ToJSON..=)) (accountAccountStatus obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountTitle" Data.Aeson.Types.ToJSON..=)) (accountAccountTitle obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountVan" Data.Aeson.Types.ToJSON..=)) (accountAccountVan obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("clearingStatus" Data.Aeson.Types.ToJSON..=)) (accountClearingStatus obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("covestor" Data.Aeson.Types.ToJSON..=)) (accountCovestor obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("currency" Data.Aeson.Types.ToJSON..=)) (accountCurrency obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("desc" Data.Aeson.Types.ToJSON..=)) (accountDesc obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("displayName" Data.Aeson.Types.ToJSON..=)) (accountDisplayName obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("faclient" Data.Aeson.Types.ToJSON..=)) (accountFaclient obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("id" Data.Aeson.Types.ToJSON..=)) (accountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("parent" Data.Aeson.Types.ToJSON..=)) (accountParent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("tradingType" Data.Aeson.Types.ToJSON..=)) (accountTradingType obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("type" Data.Aeson.Types.ToJSON..=)) (accountType obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON Account
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Account" (\obj -> ((((((((((((((GHC.Base.pure Account GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountAlias")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountStatus")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountTitle")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountVan")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "clearingStatus")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "covestor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "currency")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "desc")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "displayName")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "faclient")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "parent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "tradingType")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "type"))
-- | Create a new 'Account' with all required fields.
mkAccount :: Account
mkAccount = Account{accountAccountAlias = GHC.Maybe.Nothing,
                    accountAccountId = GHC.Maybe.Nothing,
                    accountAccountStatus = GHC.Maybe.Nothing,
                    accountAccountTitle = GHC.Maybe.Nothing,
                    accountAccountVan = GHC.Maybe.Nothing,
                    accountClearingStatus = GHC.Maybe.Nothing,
                    accountCovestor = GHC.Maybe.Nothing,
                    accountCurrency = GHC.Maybe.Nothing,
                    accountDesc = GHC.Maybe.Nothing,
                    accountDisplayName = GHC.Maybe.Nothing,
                    accountFaclient = GHC.Maybe.Nothing,
                    accountId = GHC.Maybe.Nothing,
                    accountParent = GHC.Maybe.Nothing,
                    accountTradingType = GHC.Maybe.Nothing,
                    accountType = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @components.schemas.account.properties.clearingStatus@ in the specification.
-- 
-- Status of the Account
--   * O = Open
--   * P or N = Pending
--   * A = Abandoned
--   * R = Rejected
--   * C = Closed
data AccountClearingStatus =
   AccountClearingStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | AccountClearingStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | AccountClearingStatusEnumO -- ^ Represents the JSON value @"O"@
  | AccountClearingStatusEnumP -- ^ Represents the JSON value @"P"@
  | AccountClearingStatusEnumFalse -- ^ Represents the JSON value @false@
  | AccountClearingStatusEnumA -- ^ Represents the JSON value @"A"@
  | AccountClearingStatusEnumR -- ^ Represents the JSON value @"R"@
  | AccountClearingStatusEnumC -- ^ Represents the JSON value @"C"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON AccountClearingStatus
    where toJSON (AccountClearingStatusOther val) = val
          toJSON (AccountClearingStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (AccountClearingStatusEnumO) = "O"
          toJSON (AccountClearingStatusEnumP) = "P"
          toJSON (AccountClearingStatusEnumFalse) = Data.Aeson.Types.Internal.Bool GHC.Types.False
          toJSON (AccountClearingStatusEnumA) = "A"
          toJSON (AccountClearingStatusEnumR) = "R"
          toJSON (AccountClearingStatusEnumC) = "C"
instance Data.Aeson.Types.FromJSON.FromJSON AccountClearingStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "O" -> AccountClearingStatusEnumO
                                            | val GHC.Classes.== "P" -> AccountClearingStatusEnumP
                                            | val GHC.Classes.== Data.Aeson.Types.Internal.Bool GHC.Types.False -> AccountClearingStatusEnumFalse
                                            | val GHC.Classes.== "A" -> AccountClearingStatusEnumA
                                            | val GHC.Classes.== "R" -> AccountClearingStatusEnumR
                                            | val GHC.Classes.== "C" -> AccountClearingStatusEnumC
                                            | GHC.Base.otherwise -> AccountClearingStatusOther val)
-- | Defines the enum schema located at @components.schemas.account.properties.currency@ in the specification.
-- 
-- Base currency of the account.
data AccountCurrency =
   AccountCurrencyOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | AccountCurrencyTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | AccountCurrencyEnumAUD -- ^ Represents the JSON value @"AUD"@
  | AccountCurrencyEnumGBP -- ^ Represents the JSON value @"GBP"@
  | AccountCurrencyEnumCAD -- ^ Represents the JSON value @"CAD"@
  | AccountCurrencyEnumCNH -- ^ Represents the JSON value @"CNH"@
  | AccountCurrencyEnumCZK -- ^ Represents the JSON value @"CZK"@
  | AccountCurrencyEnumDKK -- ^ Represents the JSON value @"DKK"@
  | AccountCurrencyEnumEUR -- ^ Represents the JSON value @"EUR"@
  | AccountCurrencyEnumHKD -- ^ Represents the JSON value @"HKD"@
  | AccountCurrencyEnumHUF -- ^ Represents the JSON value @"HUF"@
  | AccountCurrencyEnumINR -- ^ Represents the JSON value @"INR"@
  | AccountCurrencyEnumILS -- ^ Represents the JSON value @"ILS"@
  | AccountCurrencyEnumJPY -- ^ Represents the JSON value @"JPY"@
  | AccountCurrencyEnumMXN -- ^ Represents the JSON value @"MXN"@
  | AccountCurrencyEnumNOK -- ^ Represents the JSON value @"NOK"@
  | AccountCurrencyEnumNZD -- ^ Represents the JSON value @"NZD"@
  | AccountCurrencyEnumPLN -- ^ Represents the JSON value @"PLN"@
  | AccountCurrencyEnumRUB -- ^ Represents the JSON value @"RUB"@
  | AccountCurrencyEnumSGD -- ^ Represents the JSON value @"SGD"@
  | AccountCurrencyEnumSEK -- ^ Represents the JSON value @"SEK"@
  | AccountCurrencyEnumCHF -- ^ Represents the JSON value @"CHF"@
  | AccountCurrencyEnumUSD -- ^ Represents the JSON value @"USD"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON AccountCurrency
    where toJSON (AccountCurrencyOther val) = val
          toJSON (AccountCurrencyTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (AccountCurrencyEnumAUD) = "AUD"
          toJSON (AccountCurrencyEnumGBP) = "GBP"
          toJSON (AccountCurrencyEnumCAD) = "CAD"
          toJSON (AccountCurrencyEnumCNH) = "CNH"
          toJSON (AccountCurrencyEnumCZK) = "CZK"
          toJSON (AccountCurrencyEnumDKK) = "DKK"
          toJSON (AccountCurrencyEnumEUR) = "EUR"
          toJSON (AccountCurrencyEnumHKD) = "HKD"
          toJSON (AccountCurrencyEnumHUF) = "HUF"
          toJSON (AccountCurrencyEnumINR) = "INR"
          toJSON (AccountCurrencyEnumILS) = "ILS"
          toJSON (AccountCurrencyEnumJPY) = "JPY"
          toJSON (AccountCurrencyEnumMXN) = "MXN"
          toJSON (AccountCurrencyEnumNOK) = "NOK"
          toJSON (AccountCurrencyEnumNZD) = "NZD"
          toJSON (AccountCurrencyEnumPLN) = "PLN"
          toJSON (AccountCurrencyEnumRUB) = "RUB"
          toJSON (AccountCurrencyEnumSGD) = "SGD"
          toJSON (AccountCurrencyEnumSEK) = "SEK"
          toJSON (AccountCurrencyEnumCHF) = "CHF"
          toJSON (AccountCurrencyEnumUSD) = "USD"
instance Data.Aeson.Types.FromJSON.FromJSON AccountCurrency
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "AUD" -> AccountCurrencyEnumAUD
                                            | val GHC.Classes.== "GBP" -> AccountCurrencyEnumGBP
                                            | val GHC.Classes.== "CAD" -> AccountCurrencyEnumCAD
                                            | val GHC.Classes.== "CNH" -> AccountCurrencyEnumCNH
                                            | val GHC.Classes.== "CZK" -> AccountCurrencyEnumCZK
                                            | val GHC.Classes.== "DKK" -> AccountCurrencyEnumDKK
                                            | val GHC.Classes.== "EUR" -> AccountCurrencyEnumEUR
                                            | val GHC.Classes.== "HKD" -> AccountCurrencyEnumHKD
                                            | val GHC.Classes.== "HUF" -> AccountCurrencyEnumHUF
                                            | val GHC.Classes.== "INR" -> AccountCurrencyEnumINR
                                            | val GHC.Classes.== "ILS" -> AccountCurrencyEnumILS
                                            | val GHC.Classes.== "JPY" -> AccountCurrencyEnumJPY
                                            | val GHC.Classes.== "MXN" -> AccountCurrencyEnumMXN
                                            | val GHC.Classes.== "NOK" -> AccountCurrencyEnumNOK
                                            | val GHC.Classes.== "NZD" -> AccountCurrencyEnumNZD
                                            | val GHC.Classes.== "PLN" -> AccountCurrencyEnumPLN
                                            | val GHC.Classes.== "RUB" -> AccountCurrencyEnumRUB
                                            | val GHC.Classes.== "SGD" -> AccountCurrencyEnumSGD
                                            | val GHC.Classes.== "SEK" -> AccountCurrencyEnumSEK
                                            | val GHC.Classes.== "CHF" -> AccountCurrencyEnumCHF
                                            | val GHC.Classes.== "USD" -> AccountCurrencyEnumUSD
                                            | GHC.Base.otherwise -> AccountCurrencyOther val)
-- | Defines the enum schema located at @components.schemas.account.properties.displayName@ in the specification.
-- 
-- Whichever value is not null in this priority
data AccountDisplayName =
   AccountDisplayNameOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | AccountDisplayNameTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | AccountDisplayNameEnumAccountTitle -- ^ Represents the JSON value @"accountTitle"@
  | AccountDisplayNameEnumAccountVan -- ^ Represents the JSON value @"accountVan"@
  | AccountDisplayNameEnumAccountId -- ^ Represents the JSON value @"accountId"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON AccountDisplayName
    where toJSON (AccountDisplayNameOther val) = val
          toJSON (AccountDisplayNameTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (AccountDisplayNameEnumAccountTitle) = "accountTitle"
          toJSON (AccountDisplayNameEnumAccountVan) = "accountVan"
          toJSON (AccountDisplayNameEnumAccountId) = "accountId"
instance Data.Aeson.Types.FromJSON.FromJSON AccountDisplayName
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "accountTitle" -> AccountDisplayNameEnumAccountTitle
                                            | val GHC.Classes.== "accountVan" -> AccountDisplayNameEnumAccountVan
                                            | val GHC.Classes.== "accountId" -> AccountDisplayNameEnumAccountId
                                            | GHC.Base.otherwise -> AccountDisplayNameOther val)
-- | Defines the object schema located at @components.schemas.account.properties.parent@ in the specification.
-- 
-- 
data AccountParent = AccountParent {
  -- | accountId: Account Number for Money Manager Client
  accountParentAccountId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | isMChild: Is MM a Child Account
  , accountParentIsMChild :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | isMParent: Is MM a Parent Account
  , accountParentIsMParent :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | isMultiplex: Is a Multiplex Account. These are account models with individual account being parent and managed account being child.
  , accountParentIsMultiplex :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | mmc
  , accountParentMmc :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON AccountParent
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountId" Data.Aeson.Types.ToJSON..=)) (accountParentAccountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMChild" Data.Aeson.Types.ToJSON..=)) (accountParentIsMChild obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMParent" Data.Aeson.Types.ToJSON..=)) (accountParentIsMParent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMultiplex" Data.Aeson.Types.ToJSON..=)) (accountParentIsMultiplex obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mmc" Data.Aeson.Types.ToJSON..=)) (accountParentMmc obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("accountId" Data.Aeson.Types.ToJSON..=)) (accountParentAccountId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMChild" Data.Aeson.Types.ToJSON..=)) (accountParentIsMChild obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMParent" Data.Aeson.Types.ToJSON..=)) (accountParentIsMParent obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("isMultiplex" Data.Aeson.Types.ToJSON..=)) (accountParentIsMultiplex obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mmc" Data.Aeson.Types.ToJSON..=)) (accountParentMmc obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON AccountParent
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "AccountParent" (\obj -> ((((GHC.Base.pure AccountParent GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "accountId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "isMChild")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "isMParent")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "isMultiplex")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mmc"))
-- | Create a new 'AccountParent' with all required fields.
mkAccountParent :: AccountParent
mkAccountParent = AccountParent{accountParentAccountId = GHC.Maybe.Nothing,
                                accountParentIsMChild = GHC.Maybe.Nothing,
                                accountParentIsMParent = GHC.Maybe.Nothing,
                                accountParentIsMultiplex = GHC.Maybe.Nothing,
                                accountParentMmc = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @components.schemas.account.properties.type@ in the specification.
-- 
-- Account Type
data AccountType =
   AccountTypeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | AccountTypeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | AccountTypeEnumINDIVIDUAL -- ^ Represents the JSON value @"INDIVIDUAL"@
  | AccountTypeEnumJOINT -- ^ Represents the JSON value @"JOINT"@
  | AccountTypeEnumORG -- ^ Represents the JSON value @"ORG"@
  | AccountTypeEnumTRUST -- ^ Represents the JSON value @"TRUST"@
  | AccountTypeEnumDEMO -- ^ Represents the JSON value @"DEMO"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON AccountType
    where toJSON (AccountTypeOther val) = val
          toJSON (AccountTypeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (AccountTypeEnumINDIVIDUAL) = "INDIVIDUAL"
          toJSON (AccountTypeEnumJOINT) = "JOINT"
          toJSON (AccountTypeEnumORG) = "ORG"
          toJSON (AccountTypeEnumTRUST) = "TRUST"
          toJSON (AccountTypeEnumDEMO) = "DEMO"
instance Data.Aeson.Types.FromJSON.FromJSON AccountType
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "INDIVIDUAL" -> AccountTypeEnumINDIVIDUAL
                                            | val GHC.Classes.== "JOINT" -> AccountTypeEnumJOINT
                                            | val GHC.Classes.== "ORG" -> AccountTypeEnumORG
                                            | val GHC.Classes.== "TRUST" -> AccountTypeEnumTRUST
                                            | val GHC.Classes.== "DEMO" -> AccountTypeEnumDEMO
                                            | GHC.Base.otherwise -> AccountTypeOther val)
