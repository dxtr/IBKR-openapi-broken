-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation post_ccp_auth_init
module IBKR.Operations.Post_ccp_auth_init where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString.Char8
import qualified Data.ByteString.Char8 as Data.ByteString.Internal
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified IBKR.Common
import IBKR.Types

-- | > POST /ccp/auth/init
-- 
-- Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint \/logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
post_ccp_auth_init :: forall m . IBKR.Common.MonadHTTP m => GHC.Maybe.Maybe Post_ccp_auth_initRequestBody -- ^ The request body to send
  -> IBKR.Common.ClientT m (Network.HTTP.Client.Types.Response Post_ccp_auth_initResponse) -- ^ Monadic computation which returns the result of the operation
post_ccp_auth_init body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either Post_ccp_auth_initResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> Post_ccp_auth_initResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         Post_ccp_auth_initResponseBody200)
                                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 401) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right Post_ccp_auth_initResponse401
                                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 500) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right Post_ccp_auth_initResponse500
                                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (IBKR.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/ccp/auth/init") GHC.Base.mempty body IBKR.Common.RequestBodyEncodingFormData)
-- | Defines the object schema located at @paths.\/ccp\/auth\/init.POST.requestBody.content.application\/x-www-form-urlencoded.schema@ in the specification.
-- 
-- 
data Post_ccp_auth_initRequestBody = Post_ccp_auth_initRequestBody {
  -- | compete: Allow competing CCP session to run
  post_ccp_auth_initRequestBodyCompete :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | locale: Concatenate value for language and region, set to \"en_US\"
  , post_ccp_auth_initRequestBodyLocale :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | mac: Local MAC Address
  , post_ccp_auth_initRequestBodyMac :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | machineId: Local machine ID
  , post_ccp_auth_initRequestBodyMachineId :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | username: Login user, set to dash \"-\"
  , post_ccp_auth_initRequestBodyUsername :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON Post_ccp_auth_initRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("compete" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyCompete obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("locale" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyLocale obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mac" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyMac obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("machineId" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyMachineId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("username" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyUsername obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("compete" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyCompete obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("locale" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyLocale obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mac" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyMac obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("machineId" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyMachineId obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("username" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initRequestBodyUsername obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON Post_ccp_auth_initRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Post_ccp_auth_initRequestBody" (\obj -> ((((GHC.Base.pure Post_ccp_auth_initRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "compete")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "locale")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mac")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "machineId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "username"))
-- | Create a new 'Post_ccp_auth_initRequestBody' with all required fields.
mkPost_ccp_auth_initRequestBody :: Post_ccp_auth_initRequestBody
mkPost_ccp_auth_initRequestBody = Post_ccp_auth_initRequestBody{post_ccp_auth_initRequestBodyCompete = GHC.Maybe.Nothing,
                                                                post_ccp_auth_initRequestBodyLocale = GHC.Maybe.Nothing,
                                                                post_ccp_auth_initRequestBodyMac = GHC.Maybe.Nothing,
                                                                post_ccp_auth_initRequestBodyMachineId = GHC.Maybe.Nothing,
                                                                post_ccp_auth_initRequestBodyUsername = GHC.Maybe.Nothing}
-- | Represents a response of the operation 'post_ccp_auth_init'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'Post_ccp_auth_initResponseError' is used.
data Post_ccp_auth_initResponse =
   Post_ccp_auth_initResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | Post_ccp_auth_initResponse200 Post_ccp_auth_initResponseBody200 -- ^ Returns challenge for connection
  | Post_ccp_auth_initResponse401 -- ^ Access denied
  | Post_ccp_auth_initResponse500 -- ^ System error
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/ccp\/auth\/init.POST.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data Post_ccp_auth_initResponseBody200 = Post_ccp_auth_initResponseBody200 {
  -- | challenge: Challenge in hex format
  post_ccp_auth_initResponseBody200Challenge :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON Post_ccp_auth_initResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("challenge" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initResponseBody200Challenge obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("challenge" Data.Aeson.Types.ToJSON..=)) (post_ccp_auth_initResponseBody200Challenge obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON Post_ccp_auth_initResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "Post_ccp_auth_initResponseBody200" (\obj -> GHC.Base.pure Post_ccp_auth_initResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "challenge"))
-- | Create a new 'Post_ccp_auth_initResponseBody200' with all required fields.
mkPost_ccp_auth_initResponseBody200 :: Post_ccp_auth_initResponseBody200
mkPost_ccp_auth_initResponseBody200 = Post_ccp_auth_initResponseBody200{post_ccp_auth_initResponseBody200Challenge = GHC.Maybe.Nothing}
-- | > POST /ccp/auth/init
-- 
-- The same as 'post_ccp_auth_init' but accepts an explicit configuration.
post_ccp_auth_initWithConfiguration :: forall m . IBKR.Common.MonadHTTP m => IBKR.Common.Configuration -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe Post_ccp_auth_initRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Post_ccp_auth_initResponse) -- ^ Monadic computation which returns the result of the operation
post_ccp_auth_initWithConfiguration config
                                    body = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either Post_ccp_auth_initResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> Post_ccp_auth_initResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          Post_ccp_auth_initResponseBody200)
                                                                                                                                                                                        | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 401) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right Post_ccp_auth_initResponse401
                                                                                                                                                                                        | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 500) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right Post_ccp_auth_initResponse500
                                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (IBKR.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/ccp/auth/init") GHC.Base.mempty body IBKR.Common.RequestBodyEncodingFormData)
-- | > POST /ccp/auth/init
-- 
-- The same as 'post_ccp_auth_init' but returns the raw 'Data.ByteString.Char8.ByteString'.
post_ccp_auth_initRaw :: forall m . IBKR.Common.MonadHTTP m => GHC.Maybe.Maybe Post_ccp_auth_initRequestBody -- ^ The request body to send
  -> IBKR.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString) -- ^ Monadic computation which returns the result of the operation
post_ccp_auth_initRaw body = GHC.Base.id (IBKR.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/ccp/auth/init") GHC.Base.mempty body IBKR.Common.RequestBodyEncodingFormData)
-- | > POST /ccp/auth/init
-- 
-- The same as 'post_ccp_auth_init' but accepts an explicit configuration and returns the raw 'Data.ByteString.Char8.ByteString'.
post_ccp_auth_initWithConfigurationRaw :: forall m . IBKR.Common.MonadHTTP m => IBKR.Common.Configuration -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe Post_ccp_auth_initRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.ByteString) -- ^ Monadic computation which returns the result of the operation
post_ccp_auth_initWithConfigurationRaw config
                                       body = GHC.Base.id (IBKR.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") (Data.Text.pack "/ccp/auth/init") GHC.Base.mempty body IBKR.Common.RequestBodyEncodingFormData)
